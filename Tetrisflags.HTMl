<!DOCTYPE html>
<html lang="fa">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tetris Flags â€” Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ</title>

<!-- GSAP -->
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
<!-- Howler (Ø¨Ø±Ø§ÛŒ Ù…ÙˆØ³ÛŒÙ‚ÛŒ) -->
<script src="https://cdn.jsdelivr.net/npm/howler@2.2.4/dist/howler.min.js"></script>

<style>
  :root{
    --bg:#060606; --panel:#0f0f0f; --accent:#1db954; --muted:#bdbdbd;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family: Vazirmatn, system-ui, sans-serif;direction:rtl}
  .wrap{display:flex;flex-direction:column;align-items:center;padding:12px;gap:10px}
  h1{margin:6px 0;font-size:18px}
  #container{width:min(640px,96vw);background:var(--panel);border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(0,0,0,.6)}
  .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;gap:8px;flex-wrap:wrap}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  select,input,button{background:#141414;border:1px solid #222;color:#fff;padding:8px 10px;border-radius:8px}
  button{cursor:pointer}
  #gridWrap{width:100%;overflow:hidden;border-radius:8px;background:#000;display:flex;justify-content:center}
  #grid{position:relative;touch-action:none;user-select:none}
  .cell{position:absolute;box-sizing:border-box;border:1px solid rgba(0,0,0,0.25);background-size:cover;background-position:center;overflow:hidden}
  .overlay{position:absolute;pointer-events:none}
  .player{position:absolute;display:flex;align-items:center;justify-content:center;font-size:14px}
  .hud{display:flex;gap:8px;align-items:center;color:var(--muted)}
  .controls button.big{padding:10px 12px;border-radius:8px}
  .mobile-controls{display:flex;gap:8px;justify-content:center;margin-top:10px}
  .mobile-controls button{font-size:20px;padding:12px;border-radius:10px;background:#202020;border:none;color:#fff}
  @media (max-width:420px){
    h1{font-size:16px}
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>ğŸ® Tetris Flags â€” Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ</h1>

  <div id="container">
    <div class="topbar">
      <div style="display:flex;gap:8px;align-items:center">
        <label for="modeSelect">Ù…ÙˆØ¯:</label>
        <select id="modeSelect">
          <option value="simple">ØªØªØ±ÛŒØ³ Ú©Ù„Ø§Ø³ÛŒÚ© (Ù¾Ø±Ú†Ù…â€ŒÙ‡Ø§)</option>
          <option value="escape">ÙØ±Ø§Ø± Ø¢Ø¯Ù…Ú©</option>
        </select>
        <span class="hud" id="status">ÙˆØ¶Ø¹ÛŒØª: Ø¢Ù…Ø§Ø¯Ù‡</span>
      </div>

      <div class="controls">
        <button id="startBtn" class="big">Ø´Ø±ÙˆØ¹</button>
        <button id="pauseBtn" class="big">ØªÙˆÙ‚Ù/Ø§Ø¯Ø§Ù…Ù‡</button>
        <button id="resetBtn" class="big">Ø±ÛŒØ³Øª</button>
        <button id="soundBtn">ğŸ”Š</button>
      </div>
    </div>

    <div id="gridWrap">
      <div id="grid"></div>
    </div>

    <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px;">
      <div style="display:flex;gap:8px;align-items:center">
        <button id="leftBtn">â¬…ï¸</button>
        <button id="rotateBtn">ğŸ”„</button>
        <button id="rightBtn">â¡ï¸</button>
        <button id="downBtn">â¬‡ï¸</button>
        <button id="hardDropBtn">â¤“</button>
      </div>
      <div class="hud">Ø§Ù…ØªÛŒØ§Ø²:<span id="score">0</span> &nbsp; Ø³Ø·Ø­:<span id="level">1</span></div>
    </div>

    <div class="mobile-controls" aria-hidden="false">
      <button id="mLeft">â—€</button>
      <button id="mUp">â–²</button>
      <button id="mDown">â–¼</button>
      <button id="mRight">â–¶</button>
      <button id="mRotate">âŸ³</button>
    </div>
  </div>
</div>

<script>
/* =============================
   ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ÙˆÙ„ÛŒÙ‡
   =============================*/
const GSAP = window.gsap;
const HOWLER_SRC = ["https://archive.org/download/TetrisThemeMusic/Tetris.mp3"];
const music = new Howl({ src: HOWLER_SRC, loop: true, volume: 0.45 });
let soundOn = true;

// WebAudio for sfx (short beeps)
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const aCtx = AudioCtx ? new AudioCtx() : null;
function playBeep(freq=440, time=0.05, type='sine', gain=0.05){
  if(!aCtx) return;
  const o = aCtx.createOscillator();
  const g = aCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = gain;
  o.connect(g); g.connect(aCtx.destination);
  o.start();
  o.stop(aCtx.currentTime + time);
}

/* UI elements */
const modeSelect = document.getElementById('modeSelect');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const soundBtn = document.getElementById('soundBtn');
const statusEl = document.getElementById('status');
const gridEl = document.getElementById('grid');
const scoreEl = document.getElementById('score');
const levelEl = document.getElementById('level');

const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const rotateBtn = document.getElementById('rotateBtn');
const downBtn = document.getElementById('downBtn');
const hardDropBtn = document.getElementById('hardDropBtn');

const mLeft = document.getElementById('mLeft');
const mRight = document.getElementById('mRight');
const mUp = document.getElementById('mUp');
const mDown = document.getElementById('mDown');
const mRotate = document.getElementById('mRotate');

/* Grid config */
const COLS = 10;
const ROWS = 20;
let cellSize = 0;
let gridWidth = 420;

/* Flags list (extensive) */
const FLAGS = [
 "af","al","dz","ad","ao","ar","am","au","at","az","bd","be","bz","ba","bw","br","bg","bf","bi","kh",
 "cm","ca","cv","cl","cn","co","cr","hr","cu","cy","cz","cd","dk","dj","do","ec","eg","sv","ee","et",
 "fi","fr","ga","ge","de","gh","gr","gt","ht","hn","hk","hu","is","in","id","ir","iq","ie","il","it",
 "jp","jo","kz","ke","ki","kw","la","lv","lb","ls","lr","ly","lt","lu","mk","mg","mw","my","mv","ml",
 "mt","mr","mu","mx","md","mn","me","ma","mz","mm","np","nl","nz","ni","ng","kp","no","om","pk","pa",
 "pg","py","pe","ph","pl","pt","qa","ro","ru","rw","sa","sn","rs","sc","sl","sg","sk","si","sb","za",
 "kr","es","lk","sd","se","ch","sy","tw","tj","tz","th","tl","tg","to","tt","tn","tr","tm","ug","ua",
 "ae","uk","us","uy","uz","ve","vn","ye","zm","zw"
];
const FLAG_CACHE = {};
function getFlag(code){
  if(FLAG_CACHE[code]) return FLAG_CACHE[code];
  const img = new Image();
  img.src = `https://flagcdn.com/w80/${code}.png`;
  img.onerror = ()=>{ FLAG_CACHE[code+'_err']=true; };
  FLAG_CACHE[code]=img;
  return img;
}
function randFlag(){ return FLAGS[Math.floor(Math.random()*FLAGS.length)]; }

/* Tetris pieces (4x4 matrices for rotation convenience) */
/* 1 = block, 0 = empty */
const PIECES = {
  I: [
    [[0,0,0,0],
     [1,1,1,1],
     [0,0,0,0],
     [0,0,0,0]]
  ],
  O: [
    [[0,0,0,0],
     [0,1,1,0],
     [0,1,1,0],
     [0,0,0,0]]
  ],
  T: [
    [[0,0,0,0],
     [0,1,0,0],
     [1,1,1,0],
     [0,0,0,0]]
  ],
  S: [
    [[0,0,0,0],
     [0,1,1,0],
     [1,1,0,0],
     [0,0,0,0]]
  ],
  Z: [
    [[0,0,0,0],
     [1,1,0,0],
     [0,1,1,0],
     [0,0,0,0]]
  ],
  J: [
    [[0,0,0,0],
     [1,0,0,0],
     [1,1,1,0],
     [0,0,0,0]]
  ],
  L: [
    [[0,0,0,0],
     [0,0,1,0],
     [1,1,1,0],
     [0,0,0,0]]
  ]
};
// prepare rotations (0..3) for each piece
function rotateMat(mat){
  const N = mat.length;
  const res = Array.from({length:N}, ()=>Array(N).fill(0));
  for(let r=0;r<N;r++) for(let c=0;c<N;c++) res[c][N-1-r] = mat[r][c];
  return res;
}
const PIECE_ROTATIONS = {};
for(const p in PIECES){
  PIECE_ROTATIONS[p] = [];
  let base = PIECES[p][0];
  let cur = base;
  for(let i=0;i<4;i++){
    PIECE_ROTATIONS[p].push(cur);
    cur = rotateMat(cur);
  }
}

/* Grid model: grid[r][c] = null or {flag, domEl} */
let grid = [];
function createEmptyGrid(){
  grid = Array.from({length: ROWS}, ()=> Array(COLS).fill(null));
}

/* DOM helpers */
function resizeGrid(){
  const wrap = document.getElementById('gridWrap');
  const maxWidth = Math.min(520, wrap.clientWidth - 8);
  gridWidth = maxWidth;
  cellSize = Math.floor(gridWidth / COLS);
  gridEl.style.width = (cellSize*COLS) + 'px';
  gridEl.style.height = (cellSize*ROWS) + 'px';
  gridEl.style.position = 'relative';
  renderAll();
}
window.addEventListener('resize', resizeGrid);

/* render a fixed cell at r,c from grid */
function renderCell(r,c){
  const val = grid[r][c];
  const id = `cell-${r}-${c}`;
  let el = document.getElementById(id);
  if(val){
    if(!el){
      el = document.createElement('div');
      el.id = id; el.className = 'cell';
      el.style.position = 'absolute';
      el.style.width = cellSize + 'px';
      el.style.height = cellSize + 'px';
      gridEl.appendChild(el);
    }
    el.style.left = (c*cellSize) + 'px';
    el.style.top = (r*cellSize) + 'px';
    el.style.borderRadius = (cellSize*0.06) + 'px';
    const code = val.flag;
    if(FLAG_CACHE[code+'_err']){
      el.style.background = '#444';
      el.textContent = code.toUpperCase();
      el.style.color = '#fff';
      el.style.fontSize = Math.max(10, Math.floor(cellSize*0.28)) + 'px';
      el.style.display = 'flex';
      el.style.alignItems = 'center';
      el.style.justifyContent = 'center';
    } else {
      el.style.backgroundImage = `url(${getFlag(code).src})`;
      el.textContent = '';
      el.style.backgroundSize = 'cover';
      el.style.display = '';
    }
    el.style.visibility = 'visible';
  } else {
    if(el) el.remove();
  }
}

/* overlays for active piece */
function removeActiveOverlay(){
  const olds = gridEl.querySelectorAll('[id^="active-"]');
  olds.forEach(e=>e.remove());
}
function drawActivePiece(piece){
  removeActiveOverlay();
  if(!piece) return;
  const shape = piece.shape;
  for(let r=0;r<shape.length;r++){
    for(let c=0;c<shape[r].length;c++){
      if(shape[r][c]){
        const ar = piece.r + r;
        const ac = piece.c + c;
        const el = document.createElement('div');
        el.id = `active-${r}-${c}`;
        el.className = 'cell overlay';
        el.style.width = cellSize + 'px';
        el.style.height = cellSize + 'px';
        el.style.left = (ac*cellSize) + 'px';
        el.style.top = (ar*cellSize) + 'px';
        el.style.borderRadius = (cellSize*0.06) + 'px';
        const code = piece.flag;
        if(FLAG_CACHE[code+'_err']){
          el.style.background = '#666';
          el.textContent = code.toUpperCase();
          el.style.display = 'flex';
          el.style.alignItems = 'center';
          el.style.justifyContent = 'center';
        } else {
          el.style.backgroundImage = `url(${getFlag(code).src})`;
          el.style.backgroundSize = 'cover';
        }
        gridEl.appendChild(el);
      }
    }
  }
}

/* Utilities: collision check */
function canPlace(shape, r, c){
  for(let y=0;y<shape.length;y++){
    for(let x=0;x<shape[y].length;x++){
      if(shape[y][x]){
        const nr = r + y;
        const nc = c + x;
        if(nc < 0 || nc >= COLS) return false;
        if(nr >= ROWS) return false;
        if(nr >= 0 && grid[nr][nc]) return false;
      }
    }
  }
  return true;
}

/* lock piece into grid with animation */
function lockPiece(piece){
  playBeep(220,0.06,'square',0.06);
  const shape = piece.shape;
  const toAdd = [];
  for(let y=0;y<shape.length;y++){
    for(let x=0;x<shape[y].length;x++){
      if(shape[y][x]){
        const nr = piece.r + y;
        const nc = piece.c + x;
        if(nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS){
          grid[nr][nc] = { flag: piece.flag };
          toAdd.push({r:nr,c:nc,flag:piece.flag});
        }
      }
    }
  }
  // animate pop-in
  toAdd.forEach(cell=>{
    renderCell(cell.r,cell.c);
    const el = document.getElementById(`cell-${cell.r}-${cell.c}`);
    if(el) {
      GSAP.set(el, {scale:0.2, opacity:0});
      GSAP.to(el, {scale:1, opacity:1, duration:0.18, ease:"back.out(1.4)"});
    }
  });
}

/* clear full rows with animation */
function clearFullRows(){
  const fullRows = [];
  for(let r=0;r<ROWS;r++){
    if(grid[r].every(cell => cell !== null)) fullRows.push(r);
  }
  if(fullRows.length === 0) return 0;
  // animate rows
  fullRows.forEach((r, idx) => {
    for(let c=0;c<COLS;c++){
      const id = `cell-${r}-${c}`;
      const el = document.getElementById(id);
      if(el){
        GSAP.to(el, {y: -20, opacity:0, scale:0.6, duration:0.3, delay: idx*0.05});
      }
    }
  });
  // after animation, remove rows and collapse
  setTimeout(()=>{
    // remove DOM for those rows
    fullRows.sort((a,b)=>a-b);
    for(let ri = fullRows.length -1; ri>=0; ri--){
      const r = fullRows[ri];
      grid.splice(r,1);
      grid.unshift(Array(COLS).fill(null));
    }
    // re-render whole grid
    removeAllCells();
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) renderCell(r,c);
  }, 380 + fullRows.length*30);
  // sfx
  playBeep(880,0.08,'sine',0.04);
  return fullRows.length;
}

function removeAllCells(){
  while(gridEl.firstChild) gridEl.removeChild(gridEl.firstChild);
}

/* Piece generation (random bag) */
let bag = [];
function refillBag(){
  bag = Object.keys(PIECE_ROTATIONS).slice();
  // shuffle
  for(let i=bag.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [bag[i],bag[j]] = [bag[j],bag[i]];
  }
}
function nextPiece(){ 
  if(bag.length === 0) refillBag();
  const type = bag.shift();
  const rot = 0;
  const shape = PIECE_ROTATIONS[type][rot];
  const flag = randFlag();
  // initial position: center horizontally, r = -topOffset
  const topOffset = getTopOffset(shape);
  const startR = -topOffset;
  const startC = Math.floor((COLS - shape[0].length)/2);
  return { type, rotation: rot, shape: shape, r: startR, c: startC, flag };
}
function rotatePiece(piece){
  const rots = PIECE_ROTATIONS[piece.type];
  const nextRot = (piece.rotation + 1) % rots.length;
  const nextShape = rots[nextRot];
  return { ...piece, rotation: nextRot, shape: nextShape };
}
function getTopOffset(shape){
  for(let r=0;r<shape.length;r++){
    if(shape[r].some(v=>v)) return r;
  }
  return 0;
}

/* Game state */
let running = false;
let paused = false;
let mode = 'simple';
let current = null;
let ghost = null;
let dropInterval = 700; // ms per step; decreases with level
let dropAccumulator = 0;
let lastTime = 0;
let score = 0;
let level = 1;

/* Start / Pause / Reset */
function startGame(){
  if(!running) {
    mode = modeSelect.value;
    running = true; paused = false;
    createEmptyGrid();
    removeAllCells();
    refillBag();
    current = nextPiece();
    score = 0; level = 1;
    scoreEl.textContent = score; levelEl.textContent = level;
    dropInterval = 700;
    lastTime = performance.now();
    statusEl.textContent = `Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø²ÛŒ: ${mode}`;
    if(soundOn) try{ music.play(); }catch(e){}
    requestAnimationFrame(loop);
  } else {
    // restart
    resetGame();
    startGame();
  }
}
function pauseGame(){
  if(!running) return;
  paused = !paused;
  if(!paused){
    lastTime = performance.now();
    requestAnimationFrame(loop);
    statusEl.textContent = 'Ø§Ø¯Ø§Ù…Ù‡';
  } else {
    statusEl.textContent = 'Ù…ØªÙˆÙ‚Ù';
  }
}
function resetGame(){
  running = false; paused = false;
  createEmptyGrid();
  removeAllCells();
  current = null;
  refillBag();
  score = 0; level = 1;
  scoreEl.textContent = score; levelEl.textContent = level;
  try{ music.stop(); }catch(e){}
  statusEl.textContent = 'Ø¢Ù…Ø§Ø¯Ù‡';
}

/* Drop & Lock logic */
function hardDrop(){
  if(!current) return;
  while(true){
    if(canPlace(current.shape, current.r+1, current.c)) current.r++;
    else break;
  }
  lockAndNext();
  playBeep(520,0.02,'square',0.06);
}
function softDrop(){
  if(!current) return;
  if(canPlace(current.shape, current.r+1, current.c)) {
    current.r++;
    score += 1;
    scoreEl.textContent = score;
    playBeep(400,0.02,'sine',0.02);
  } else {
    lockAndNext();
  }
}
function moveLeft(){
  if(!current) return;
  if(canPlace(current.shape, current.r, current.c-1)){
    current.c--;
    playBeep(260,0.02,'sine',0.02);
  }
}
function moveRight(){
  if(!current) return;
  if(canPlace(current.shape, current.r, current.c+1)){
    current.c++;
    playBeep(260,0.02,'sine',0.02);
  }
}
function rotateCW(){
  if(!current) return;
  const rots = PIECE_ROTATIONS[current.type];
  const nextRot = (current.rotation + 1) % rots.length;
  const nextShape = rots[nextRot];
  // try kicks: basic wall kick attempts
  const kicks = [[0,0],[0,-1],[0,1],[-1,0],[1,0]];
  for(const k of kicks){
    const nr = current.r + k[0];
    const nc = current.c + k[1];
    if(canPlace(nextShape, nr, nc)){
      current.rotation = nextRot;
      current.shape = nextShape;
      current.r = nr; current.c = nc;
      playBeep(600,0.03,'triangle',0.03);
      return;
    }
  }
}

/* lock current piece and spawn next */
function lockAndNext(){
  lockPiece(current);
  const cleared = clearFullRows();
  if(cleared > 0){
    score += 100 * cleared;
    level = Math.min(20, Math.floor(score/500) + 1);
    dropInterval = Math.max(120, 700 - (level-1) * 30);
    levelEl.textContent = level;
    playBeep(900,0.12,'sine',0.05);
  }
  current = nextPiece();
  // check immediate collision -> game over
  if(!canPlace(current.shape, current.r, current.c)){
    gameOver();
  }
}

/* game over */
function gameOver(){
  running = false;
  paused = false;
  try{ music.stop(); }catch(e){}
  statusEl.textContent = 'Ø¨Ø§Ø®Øª';
  playBeep(120,0.4,'sine',0.08);
  setTimeout(()=> alert('Ø¨Ø§Ø®ØªÛŒ! Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†.'), 50);
}

/* render all static cells and active piece */
function renderAll(){
  // render static grid
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) renderCell(r,c);
  // render active piece overlay
  drawActivePiece(current);
}

/* Game loop (requestAnimationFrame) */
function loop(now){
  if(!running || paused) return;
  const dt = now - lastTime;
  lastTime = now;
  dropAccumulator += dt;
  // step
  if(dropAccumulator >= dropInterval){
    dropAccumulator -= dropInterval;
    if(mode === 'simple'){
      if(canPlace(current.shape, current.r+1, current.c)){
        current.r++;
      } else {
        lockAndNext();
      }
    } else if(mode === 'escape'){
      // in escape: spawn and patterns settle into grid (simpler approach preserved from earlier)
      // We'll reuse a simple escape logic: spawn horizontal patterns guaranteeing a hole
      // For brevity we use a local spawn scheduler implemented below (escape-specific)
      escapeTick();
    }
  }
  renderAll();
  requestAnimationFrame(loop);
}

/* =========================
   Escape mode: patterns dropping (grid-based)
   =========================*/
let escapePatterns = [];
let escapeSpawnAcc = 0;
let escapeSpawnInterval = 1000;
function spawnEscapePattern(){
  // patterns generated like earlier, but we ensure at least one column hole
  const t = Math.random();
  const blocks = [];
  if(t < 0.5){
    // row with 1-2 holes
    let holes = Math.random() < 0.7 ? 1 : 2;
    const holeIdx = [];
    while(holeIdx.length < holes){
      const idx = Math.floor(Math.random()*COLS);
      if(!holeIdx.includes(idx)) holeIdx.push(idx);
    }
    for(let c=0;c<COLS;c++){
      if(!holeIdx.includes(c)) blocks.push({r: -1, c, flag: randFlag()});
    }
  } else if(t < 0.8){
    // some columns
    const cnt = 3 + Math.floor(Math.random()*3);
    const cols = [];
    while(cols.length < cnt){
      const c = Math.floor(Math.random()*COLS);
      if(!cols.includes(c)) cols.push(c);
    }
    cols.forEach(c=>{
      const h = 1 + Math.floor(Math.random()*2);
      for(let k=0;k<h;k++) blocks.push({r: -1 - k, c, flag: randFlag()});
    });
  } else {
    // random single blocks
    const cnt = 2 + Math.floor(Math.random()*4);
    for(let i=0;i<cnt;i++){
      const c = Math.floor(Math.random()*COLS);
      blocks.push({r: -1 - Math.floor(Math.random()*3), c, flag: randFlag()});
    }
  }
  // ensure at least one hole at settle: compute max fall
  let maxFall = ROWS;
  for(const b of blocks){
    let fall = 0;
    for(let r = b.r + 1; r < ROWS; r++)<!DOCTYPE html>
<html lang="fa">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tetris Flags â€” Ù¾ÛŒØ´Ø±ÙØªÙ‡</title>

<!-- Libraries -->
<script src="https://cdn.jsdelivr.net/npm/howler@2.2.4/dist/howler.min.js"></script>

<style>
  :root{
    --bg:#050505;
    --panel:#0b0b0b;
    --accent:#1db954;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family: Vazirmatn, system-ui, sans-serif;}
  .wrap{display:flex;flex-direction:column;align-items:center;padding:12px;gap:10px;}
  h1{margin:6px 0;font-size:18px}
  #gameWrap{width:min(420px,92vw);max-width:420px;background:var(--panel);border-radius:12px;padding:10px;box-shadow:0 6px 24px rgba(0,0,0,.6);}
  #game{position:relative;margin:0 auto;background:#000;border-radius:6px;overflow:hidden;touch-action:none;}
  .ui{display:flex;gap:8px;justify-content:center;margin-top:8px;flex-wrap:wrap;}
  button{background:#222;border:none;color:#fff;padding:10px 12px;border-radius:8px;font-size:15px}
  .small{padding:6px 8px;font-size:13px}
  .score{font-size:14px;margin-left:8px}
  /* responsive sizes */
  @media (max-width:420px){
    h1{font-size:16px}
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>ğŸ® Tetris Flags â€” Ù¾ÛŒØ´Ø±ÙØªÙ‡</h1>
  <div id="gameWrap">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
      <div>
        <select id="modeSelect" aria-label="mode">
          <option value="simple">ØªØªØ±ÛŒØ³ Ø³Ø§Ø¯Ù‡ (Ø¨Ø§Ø±Ø´ Ù¾Ø±Ú†Ù…)</option>
          <option value="escape">ÙØ±Ø§Ø± Ø¢Ø¯Ù…Ú©</option>
        </select>
        <span class="score" id="status">ÙˆØ¶Ø¹ÛŒØª: Ø¢Ù…Ø§Ø¯Ù‡</span>
      </div>
      <div>
        <button id="startBtn">Ø´Ø±ÙˆØ¹</button>
        <button id="pauseBtn" class="small">ØªÙˆÙ‚Ù</button>
      </div>
    </div>

    <!-- Ø¨Ø§Ø²ÛŒ -->
    <div id="game" style="width:100%;height:66vw;max-height:560px;"></div>

    <div class="ui">
      <button id="leftBtn">â¬…ï¸</button>
      <button id="upBtn">â¬†ï¸</button>
      <button id="rightBtn">â¡ï¸</button>
      <button id="downBtn">â¬‡ï¸</button>
      <button id="soundToggle" class="small">ğŸ”Š</button>
    </div>
  </div>
</div>

<script>
/* ====== ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ùˆ Ù„ÙˆØ¯ ØµØ¯Ø§ ====== */
const music = new Howl({ src: ["https://archive.org/download/TetrisThemeMusic/Tetris.mp3"], loop:true, volume:0.45 });
let soundOn = true;

/* ====== Ø§Ù„Ù…Ø§Ù†â€ŒÙ‡Ø§ ====== */
const gameEl = document.getElementById('game');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const modeSelect = document.getElementById('modeSelect');
const statusEl = document.getElementById('status');
const soundToggle = document.getElementById('soundToggle');

/* ====== Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ø±ÛŒØ³Ù¾Ø§Ù†Ø³ÛŒÙˆ Ùˆ Ú¯Ø±ÛŒØ¯ ====== */
let GW, GH, COLS=10, blockSize;
function resizeGame(){
  // Ø§Ø±ØªÙØ§Ø¹ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¹Ø±Ø¶ Ø¸Ø±Ù (Ù†Ø³Ø¨Øª Ù‚Ø§Ø¨Ù„ ØªØºÛŒÛŒØ±)
  GW = gameEl.clientWidth;
  GH = Math.min(Math.floor(GW*1.6), 560); // Ù†Ø³Ø¨Øª Ùˆ Ø­Ø¯ Ø¨ÛŒØ´ÛŒÙ†Ù‡
  gameEl.style.height = GH + 'px';
  blockSize = GW / COLS;
}
window.addEventListener('resize', resizeGame);
resizeGame();

/* ====== Ù¾Ø±Ú†Ù…â€ŒÙ‡Ø§ ====== */
const FLAGS = ["ir","us","de","fr","jp","br","gb","it","es","tr","ca","au","kr"];
const imgCache = {};
function flagImg(code){
  if(!imgCache[code]){
    const img = new Image();
    img.src = `https://flagcdn.com/w80/${code}.png`;
    imgCache[code] = img;
  }
  return imgCache[code];
}
function randFlag(){ return FLAGS[Math.floor(Math.random()*FLAGS.length)]; }

/* ====== ÙˆØ¶Ø¹ÛŒØª Ú©Ù„ÛŒ Ø¨Ø§Ø²ÛŒ ====== */
let mode = 'simple'; // simple | escape
let running = false;
let paused = false;
let lastTime = 0;
let blocks = []; // Ø¢Ø±Ø§ÛŒÙ‡ Ø¢Ø¨Ø¬Ú©Øª Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§ÛŒ Ø§ÙØªØ§Ù†
let player = null; // Ø¨Ø±Ø§ÛŒ Ù…Ø¯ escape
let spawnTimer = 0;
let spawnInterval = 700; // Ù…ÛŒÙ„ÛŒâ€ŒØ«Ø§Ù†ÛŒÙ‡
let simpleFallSpeed = 90; // pixels per second
let escapeFallBase = 160; // pixels per second
let frameReq = null;
let score = 0;

/* ====== Ø¢Ø¨Ø¬Ú©Øª Ø¨Ù„ÙˆÚ© ======
{ id, x(px), y(px), w(px), h(px), flag(code), vy }
=================================*/
let idCounter = 1;
function makeBlock(px, py, w, h, flag, vy){
  const el = document.createElement('img');
  el.draggable = false;
  el.className = 'game-block';
  el.style.position = 'absolute';
  el.style.width = w + 'px';
  el.style.height = h + 'px';
  el.style.left = px + 'px';
  el.style.top = py + 'px';
  el.src = `https://flagcdn.com/w40/${flag}.png`;
  gameEl.appendChild(el);
  return { id: idCounter++, el, x:px, y:py, w, h, flag, vy };
}

/* ====== Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ ====== */
function resetGame(){
  cancelAnimationFrame(frameReq);
  blocks.forEach(b => b.el.remove());
  blocks = [];
  if(player && player.el) player.el.remove();
  player = null;
  idCounter = 1;
  lastTime = 0;
  spawnTimer = 0;
  score = 0;
  statusEl.textContent = 'ÙˆØ¶Ø¹ÛŒØª: Ø¢Ù…Ø§Ø¯Ù‡';
}

/* ====== Ø´Ø±ÙˆØ¹ Ù…ÙˆØ¯ Ù‡Ø§ ====== */
function start(){
  mode = modeSelect.value;
  resetGame();
  resizeGame();
  running = true;
  paused = false;
  if(soundOn) try{ music.play(); }catch(e){}
  statusEl.textContent = `ÙˆØ¶Ø¹ÛŒØª: Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø²ÛŒ (${mode==="simple"?"ØªØªØ±ÛŒØ³ Ø³Ø§Ø¯Ù‡":"ÙØ±Ø§Ø± Ø¢Ø¯Ù…Ú©"})`;
  if(mode === 'simple'){
    spawnInterval = 700;
    simpleFallSpeed = Math.max(40, GW * 0.25); // px/s proportional
    // ØªØ±Ø§Ø² Ø¨Ù†Ø¯ÛŒØ› Ø¯Ø± Ù…ÙˆØ¯ Ø³Ø§Ø¯Ù‡ Ù‡Ø± Ø¨Ù„Ø§Ú© Ø¯Ø± ÛŒÚ©ÛŒ Ø§Ø² 10 Ø³ØªÙˆÙ†
  } else {
    spawnInterval = 600;
    escapeFallBase = Math.max(120, GW * 0.35);
    createPlayer();
  }
  lastTime = performance.now();
  frameReq = requestAnimationFrame(loop);
}

/* ====== Ù…Ú©Ø§Ù†ÛŒØ³Ù… ØªÙˆÙ„ÛŒØ¯ Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§ ====== */
function spawnSimpleBlock(){
  // ÛŒÚ© Ø¨Ù„ÙˆÚ© ØªÚ© Ø¯Ø± ÛŒÚ©ÛŒ Ø§Ø² Ø³ØªÙˆÙ†â€ŒÙ‡Ø§
  const col = Math.floor(Math.random() * COLS);
  const px = col * blockSize;
  const py = -blockSize;
  const flag = randFlag();
  const b = makeBlock(px, py, blockSize, blockSize, flag, simpleFallSpeed / 1000); // vy in px/ms
  blocks.push(b);
}

function spawnEscapePattern(){
  // Ø§Ù„Ú¯ÙˆÙ‡Ø§ Ø¨Ø§ ØªØ¶Ù…ÛŒÙ† Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© Ø³ÙˆØ±Ø§Ø®
  const patternType = Math.random();
  if(patternType < 0.45){
    // Ø±Ø¯ÛŒÙ Ø¨Ø§ 1-2 Ø³ÙˆØ±Ø§Ø®: ØªÙˆÙ„ÛŒØ¯ Ù…Ø¬Ù…ÙˆØ¹Ù‡ Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§ Ø¯Ø± Ù‡Ø± Ø³ØªÙˆÙ† Ø¨Ù‡ Ø¬Ø² Ø¬Ø§Ù‡Ø§ÛŒ Ø®Ø§Ù„ÛŒ
    let holes = Math.random() < 0.6 ? 1 : 2;
    let holeIndexes = [];
    while(holeIndexes.length < holes){
      const idx = Math.floor(Math.random()*COLS);
      if(!holeIndexes.includes(idx)) holeIndexes.push(idx);
    }
    for(let c=0;c<COLS;c++){
      if(!holeIndexes.includes(c)){
        const px = c*blockSize;
        const py = -blockSize;
        const flag = randFlag();
        const b = makeBlock(px,py,blockSize,blockSize,flag,escapeFallBase/1000 + (Math.random()*40)/1000);
        blocks.push(b);
      }
    }
  } else if(patternType < 0.75){
    // Ø³ØªÙˆÙ†â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø§Ú©Ù†Ø¯Ù‡ (3-5 Ø³ØªÙˆÙ†)
    const count = 3 + Math.floor(Math.random()*3);
    let cols = [];
    while(cols.length < count){
      const c = Math.floor(Math.random()*COLS);
      if(!cols.includes(c)) cols.push(c);
    }
    cols.forEach(c=>{
      const px = c*blockSize;
      const py = -blockSize - Math.random()*100;
      const hMult = 1 + Math.floor(Math.random()*2); // Ú¯Ø§Ù‡ÛŒ Ø¯Ùˆ Ø±Ø¯ÛŒÙÙ‡
      for(let r=0;r<hMult;r++){
        const flag = randFlag();
        const b = makeBlock(px, py - r*blockSize, blockSize, blockSize, flag, (escapeFallBase + Math.random()*60)/1000);
        blocks.push(b);
      }
    });
  } else {
    // Ú†Ù†Ø¯ ØªÚ© Ø¨Ù„ÙˆÚ© ØªØµØ§Ø¯ÙÛŒ
    const count = 2 + Math.floor(Math.random()*4);
    for(let i=0;i<count;i++){
      const c = Math.floor(Math.random()*COLS);
      const px = c*blockSize;
      const py = -blockSize - Math.random()*200;
      const flag = randFlag();
      const b = makeBlock(px,py,blockSize,blockSize,flag,(escapeFallBase + Math.random()*80)/1000);
      blocks.push(b);
    }
  }
}

/* ====== Ø§ÛŒØ¬Ø§Ø¯ Ø¢Ø¯Ù…Ú© Ùˆ ÙÛŒØ²ÛŒÚ©Ø´ ====== */
function createPlayer(){
  const el = document.createElement('div');
  el.style.position='absolute';
  el.style.width= blockSize + 'px';
  el.style.height= Math.round(blockSize*1.2) + 'px';
  el.style.left = Math.round((COLS/2 - 0.5) * blockSize) + 'px';
  el.style.bottom = '6px';
  el.style.background = '#1db954';
  el.style.borderRadius = '6px';
  el.style.display = 'flex';
  el.style.alignItems = 'center';
  el.style.justifyContent = 'center';
  el.style.fontWeight='700';
  el.textContent = 'ğŸ™‚';
  gameEl.appendChild(el);
  player = {
    el,
    x: parseFloat(el.style.left),
    y: 6, // bottom
    w: blockSize,
    h: Math.round(blockSize*1.2),
    vy: 0,
    onGround: true
  };
}

/* ====== Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ ====== */
function movePlayer(dx){
  if(!player) return;
  player.x = Math.max(0, Math.min(GW - player.w, player.x + dx));
  player.el.style.left = player.x + 'px';
}
function playerJump(){
  if(!player) return;
  if(player.onGround){
    player.vy = -13; // initial jump velocity (px/frame)
    player.onGround = false;
  }
}

/* ====== Ø¨Ø±Ø®ÙˆØ±Ø¯ ==== */
function rectsOverlap(a,b){
  return !(a.left >= b.right || a.right <= b.left || a.top >= b.bottom || a.bottom <= b.top);
}

function checkCollisions(){
  if(mode === 'escape' && player){
    const pr = player.el.getBoundingClientRect();
    const gwRect = gameEl.getBoundingClientRect();
    // normalize block rects relative to viewport
    for(const b of blocks){
      const br = b.el.getBoundingClientRect();
      if(rectsOverlap(pr, br)){
        // Ø¨Ø±Ø®ÙˆØ±Ø¯! Ø¨Ø§Ø®Øª
        statusEl.textContent = 'Ø¨Ø§Ø®ØªÛŒ â€” Ø¨Ø±Ø®ÙˆØ±Ø¯ Ø´Ø¯';
        running = false;
        music.stop();
        cancelAnimationFrame(frameReq);
        alert('ğŸ’¥ Ø¨Ø§Ø®ØªÛŒ! Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†.');
        return true;
      }
    }
  }
  return false;
}

/* ====== Ù„ÙˆÙ¾ Ø§ØµÙ„ÛŒ ====== */
function loop(now){
  if(!running || paused) return;
  const dt = Math.min(40, now - lastTime); // ms, clamp Ø¨Ø±Ø§ÛŒ Ø«Ø¨Ø§Øª
  lastTime = now;

  // spawn Ú©Ù†ØªØ±Ù„
  spawnTimer += dt;
  if(spawnTimer >= spawnInterval){
    spawnTimer = 0;
    if(mode === 'simple') spawnSimpleBlock();
    else spawnEscapePattern();
  }

  // Ø­Ø±Ú©Øª Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§
  for(let i = blocks.length -1; i >=0; i--){
    const b = blocks[i];
    b.y += b.vy * dt; // vy in px/ms
    if(b.y > GH + 50){
      // Ø­Ø°Ù
      b.el.remove();
      blocks.splice(i,1);
      if(mode === 'simple') score += 1;
      continue;
    }
    b.el.style.top = b.y + 'px';
  }

  // Ù…ÙˆØ¯ Ø³Ø§Ø¯Ù‡: Ø§Ù…Ú©Ø§Ù† Ú©Ù†ØªØ±Ù„ Ø¯Ø³ØªÛŒ Ø¬Ø§ Ø¨Ù‡ Ø¬Ø§ÛŒÛŒ Ø³ØªÙˆÙ†â€ŒÙ‡Ø§ (Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¨Ø§ Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ Ø³ØªÙˆÙ† Ø±Ø§ Ø¬Ø§Ø¨Ø¬Ø§ Ù…ÛŒâ€ŒÚ©Ù†Ø¯)
  // Ø¯Ø± Ù…ÙˆØ¯ Ø³Ø§Ø¯Ù‡ Ú©Ø§Ø±Ø¨Ø± Ø³ØªÙˆÙ†â€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ø§ Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ Ø¬Ø§Ø¨Ø¬Ø§ Ù…ÛŒâ€ŒÚ©Ù†Ø¯: Ø¨Ø±Ø§ÛŒ Ø¢Ø³Ø§Ù† Ø´Ø¯Ù† Ø¨Ø§Ø²ÛŒØŒ  
  // Ù‡Ø± ÙØ´Ø§Ø± Ø¯Ú©Ù…Ù‡ØŒ Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§ÛŒÛŒ Ú©Ù‡ Ù‡Ù†ÙˆØ² Ù†Ø²Ø¯ÛŒÚ© Ø³Ø·Ø­ Ø¨Ø§Ù„Ø§ Ù‡Ø³ØªÙ†Ø¯ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ù†Ø¯ Ø¬Ø§ÛŒ Ø®ÙˆØ¯ Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ù‡Ù†Ø¯.
  // (Ø¨Ø±Ø§ÛŒ ØªØ¬Ø±Ø¨Ù‡ Ø³Ø§Ø¯Ù‡â€ŒØªØ±ØŒâ€Œ Ù…Ø§ Ø§Ø¬Ø§Ø²Ù‡ Ù†Ù…ÛŒâ€ŒØ¯Ù‡ÛŒÙ… Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§ÛŒ Ø§ÙØªØ§Ø¯Ù‡ Ø¬Ø§Ø¨Ø¬Ø§ Ø´ÙˆÙ†Ø¯.)
  // â€” Ù†Ø³Ø®Ù‡ Ù¾Ø§ÛŒÙ‡: Ù‡ÛŒÚ† ØªØºÛŒÛŒØ± Ù†ÛŒØ§Ø² Ù†Ø¯Ø§Ø±Ø¯Ø› Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§ ÙÙ‚Ø· Ù…ÛŒâ€ŒØ§ÙØªÙ†Ø¯ ØªØ§ Ø®ÙˆØ¯Øª Ø¨Ú†ÛŒÙ†ÛŒ.

  // Ù…ÙˆØ¯ escape: ÙÛŒØ²ÛŒÚ© Ø¢Ø¯Ù…Ú©
  if(mode === 'escape' && player){
    // gravity (ÙØ±Ù…ÙˆÙ„ ÙØ±ÛŒÙ…â€ŒØ¨Ù†Ø¯ÛŒ Ù…Ø³ØªÙ‚Ù„)
    player.vy += 0.7; // gravity per frame
    player.y += player.vy;
    if(player.y >= 6){
      player.y = 6;
      player.vy = 0;
      player.onGround = true;
    } else {
      player.onGround = false;
    }
    player.el.style.bottom = player.y + 'px';
  }

  // Ø¨Ø±Ø®ÙˆØ±Ø¯
  if(checkCollisions()) return;

  // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª (Ø§Ù…ØªÛŒØ§Ø²)
  if(mode === 'simple') statusEl.textContent = `Ø§Ù…ØªÛŒØ§Ø²: ${score} â€” ØªØªØ±ÛŒØ³ Ø³Ø§Ø¯Ù‡`;
  frameReq = requestAnimationFrame(loop);
}

/* ====== Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ Ùˆ Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ ====== */
startBtn.addEventListener('click', ()=>{
  if(!running) start();
  else { // restart
    resetGame(); start();
  }
});
pauseBtn.addEventListener('click', ()=>{
  if(!running) return;
  paused = !paused;
  if(!paused){
    lastTime = performance.now();
    frameReq = requestAnimationFrame(loop);
    statusEl.textContent = `Ø§Ø¯Ø§Ù…Ù‡ â€” ${mode}`;
  } else {
    statusEl.textContent = `Ù…ØªÙˆÙ‚Ù â€” ${mode}`;
  }
});

document.getElementById('leftBtn').addEventListener('click', ()=> {
  if(mode === 'escape') movePlayer(-blockSize);
  else {
    // Ø¯Ø± Ù…ÙˆØ¯ Ø³Ø§Ø¯Ù‡: Ø­Ø±Ú©Øª Ú©Ù†Ø¯ Ø¨Ø±Ø§ÛŒ Ø¯Ø³ØªÚ©Ø§Ø±ÛŒ Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ù„Ø§ÛŒÛŒ
    // Ø¬Ø§Ø¨Ø¬Ø§ÛŒÛŒ Ø¢Ø®Ø±ÛŒÙ† Ø¨Ù„ÙˆÚ© Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯Ù‡ Ù‚Ø¨Ù„ Ø§Ø² Ø±Ø³ÛŒØ¯Ù† Ø¨Ù‡ Ù¾Ø§ÛŒÛŒÙ† (Ø¨Ø³ÛŒØ§Ø± Ø³Ø§Ø¯Ù‡)
    if(blocks.length){
      const topBlock = blocks[blocks.length-1];
      topBlock.x = Math.max(0, topBlock.x - blockSize);
      topBlock.el.style.left = topBlock.x + 'px';
    }
  }
});
document.getElementById('rightBtn').addEventListener('click', ()=> {
  if(mode === 'escape') movePlayer(blockSize);
  else {
    if(blocks.length){
      const topBlock = blocks[blocks.length-1];
      topBlock.x = Math.min((COLS-1)*blockSize, topBlock.x + blockSize);
      topBlock.el.style.left = topBlock.x + 'px';
    }
  }
});
document.getElementById('upBtn').addEventListener('click', ()=> {
  if(mode === 'escape') playerJump();
  else {
    // Ø¯Ø± Ù…ÙˆØ¯ Ø³Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ°Ø§Ø±ÛŒÙ… Ø¯Ú©Ù…Ù‡ Ø¨Ø§Ù„Ø§ Ø¨Ù„ÙˆÚ© Ú©Ù†ÙˆÙ†ÛŒ Ø±Ùˆ "Ø³Ø±ÛŒØ¹ Ù¾Ø§ÛŒÛŒÙ†" Ø¨Ù†Ø¯Ø§Ø²Ù‡ (soft drop)
    if(blocks.length){
      const topBlock = blocks[blocks.length-1];
      topBlock.y += blockSize*2;
      topBlock.el.style.top = topBlock.y + 'px';
    }
  }
});
document.getElementById('downBtn').addEventListener('click', ()=> {
  if(mode === 'escape') playerJump();
  else {
    // Ù†Ú¯Ù‡ Ø¯Ø§Ø´ØªÙ† Ø¨Ø±Ø§ÛŒ Ø´ØªØ§Ø¨
    if(blocks.length){
      const topBlock = blocks[blocks.length-1];
      topBlock.y += blockSize;
      topBlock.el.style.top = topBlock.y + 'px';
    }
  }
});

/* Ú©ÛŒØ¨ÙˆØ±Ø¯ */
window.addEventListener('keydown', (e) => {
  if(e.key === 'ArrowLeft') document.getElementById('leftBtn').click();
  if(e.key === 'ArrowRight') document.getElementById('rightBtn').click();
  if(e.key === 'ArrowUp') document.getElementById('upBtn').click();
  if(e.key === ' ') {
    e.preventDefault();
    document.getElementById('upBtn').click();
  }
});

/* Ù„Ù…Ø³ Ø³ÙˆØ§ÛŒÙ¾ Ø³Ø§Ø¯Ù‡ (Ø¨Ø±Ø§ÛŒ Ù…ÙˆØ¨Ø§ÛŒÙ„) */
let touchStartX = null, touchStartY = null;
gameEl.addEventListener('touchstart', (ev)=>{
  if(ev.touches && ev.touches.length){
    touchStartX = ev.touches[0].clientX;
    touchStartY = ev.touches[0].clientY;
  }
}, {passive:true});
gameEl.addEventListener('touchend', (ev)=>{
  if(touchStartX === null) return;
  const dx = (ev.changedTouches[0].clientX - touchStartX);
  const dy = (ev.changedTouches[0].clientY - touchStartY);
  if(Math.abs(dx) > Math.abs(dy)){
    if(dx < -20) document.getElementById('leftBtn').click();
    else if(dx > 20) document.getElementById('rightBtn').click();
  } else {
    if(dy < -40) document.getElementById('upBtn').click(); // swipe up -> jump
    else if(dy > 40) document.getElementById('downBtn').click();
  }
  touchStartX = null;
  touchStartY = null;
}, {passive:true});

/* ØµØ¯Ø§ */
soundToggle.addEventListener('click', ()=>{
  soundOn = !soundOn;
  if(soundOn) music.play();
  else music.stop();
  soundToggle.textContent = soundOn ? 'ğŸ”Š' : 'ğŸ”ˆ';
});

/* ÙˆÙ‚ØªÛŒ ØµÙØ­Ù‡ Ù„ÙˆØ¯ Ø´Ø¯ Ø§Ù†Ø¯Ø§Ø²Ù‡ Ùˆ Ù…Ø­ØªÙˆØ§ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ø±Ø§ ØªÙ†Ø¸ÛŒÙ… Ú©Ù† */
window.addEventListener('load', ()=>{
  resizeGame();
  statusEl.textContent = 'ÙˆØ¶Ø¹ÛŒØª: Ø¢Ù…Ø§Ø¯Ù‡';
  // preload flag images
  FLAGS.forEach(f => flagImg(f));
});
</script>
</body>
</html>  overflow:hidden;
  border:3px solid #fff;
}
.block{
  position:absolute;
  width:30px;
  height:30px;
}
#player{
  position:absolute;
  bottom:10px;
  left:135px;
  width:30px;
  height:40px;
  background:#00ffcc;
  border-radius:6px;
}
.controls{
  margin:10px;
}
.controls button{
  font-size:22px;
  padding:10px 15px;
}
</style>
</head>
<body>

<h2>ğŸ® Tetris Flags â€“ Game Pack</h2>

<div id="menu">
  <button onclick="startTetris()">ğŸ§± ØªØªØ±ÛŒØ³ Ø³Ø§Ø¯Ù‡</button>
  <button onclick="startEscape()">ğŸƒ ÙØ±Ø§Ø± Ø¢Ø¯Ù…Ú©</button>
</div>

<div id="game"></div>

<div class="controls">
  <button onclick="moveLeft()">â¬…ï¸</button>
  <button onclick="jump()">â¬†ï¸</button>
  <button onclick="moveRight()">â¡ï¸</button>
</div>

<script>
// ===== Sound =====
const music = new Howl({
  src:["https://archive.org/download/TetrisThemeMusic/Tetris.mp3"],
  loop:true,
  volume:0.5
});

// ===== Flags =====
const flags=["ir","us","de","fr","jp","br","gb","it","es","tr"];
const game=document.getElementById("game");
let mode=null;
let blocks=[];
let player=null;
let gravity=0;
let jumping=false;

// ===== Utils =====
function randomFlag(){
  return flags[Math.floor(Math.random()*flags.length)];
}

function createBlock(x,y){
  const b=document.createElement("img");
  b.src=`https://flagcdn.com/w40/${randomFlag()}.png`;
  b.className="block";
  b.style.left=x+"px";
  b.style.top=y+"px";
  game.appendChild(b);
  blocks.push(b);

  gsap.to(b,{
    y:500,
    duration:mode==="escape"?2:4,
    ease:"linear",
    onComplete:()=>b.remove()
  });
}

// ===== MODE 1: TETRIS SIMPLE =====
function startTetris(){
  reset();
  mode="tetris";
  music.play();

  setInterval(()=>{
    for(let i=0;i<10;i++){
      createBlock(i*30,-30);
    }
  },1200);
}

// ===== MODE 2: ESCAPE =====
function startEscape(){
  reset();
  mode="escape";
  music.play();

  player=document.createElement("div");
  player.id="player";
  game.appendChild(player);

  setInterval(()=>{
    createBlock(Math.floor(Math.random()*10)*30,-30);
  },600);

  requestAnimationFrame(escapeLoop);
}

function escapeLoop(){
  if(!player) return;

  // gravity
  if(jumping){
    gravity+=1;
    player.style.bottom=(parseInt(player.style.bottom)-gravity)+"px";
    if(parseInt(player.style.bottom)<=10){
      jumping=false;
      gravity=0;
      player.style.bottom="10px";
    }
  }

  // collision
  blocks.forEach(b=>{
    const br=b.getBoundingClientRect();
    const pr=player.getBoundingClientRect();
    if(
      br.left<pr.right &&
      br.right>pr.left &&
      br.bottom>pr.top &&
      br.top<pr.bottom
    ){
      alert("ğŸ’¥ Ø¨Ø§Ø®ØªÛŒ!");
      reset();
    }
  });

  requestAnimationFrame(escapeLoop);
}

// ===== Controls =====
function moveLeft(){
  if(player){
    player.style.left=Math.max(0,player.offsetLeft-30)+"px";
  }
}
function moveRight(){
  if(player){
    player.style.left=Math.min(270,player.offsetLeft+30)+"px";
  }
}
function jump(){
  if(player && !jumping){
    jumping=true;
    gravity=-15;
  }
}

// ===== Reset =====
function reset(){
  game.innerHTML="";
  blocks=[];
  player=null;
  music.stop();
}
</script>

</body>
</html>
<!DOCTYPE html>
<html lang="fa">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tetris Flags â€” Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ</title>

<!-- GSAP -->
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
<!-- Howler (Ø¨Ø±Ø§ÛŒ Ù…ÙˆØ³ÛŒÙ‚ÛŒ) -->
<script src="https://cdn.jsdelivr.net/npm/howler@2.2.4/dist/howler.min.js"></script>

<style>
  :root{
    --bg:#060606; --panel:#0f0f0f; --accent:#1db954; --muted:#bdbdbd;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family: Vazirmatn, system-ui, sans-serif;direction:rtl}
  .wrap{display:flex;flex-direction:column;align-items:center;padding:12px;gap:10px}
  h1{margin:6px 0;font-size:18px}
  #container{width:min(640px,96vw);background:var(--panel);border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(0,0,0,.6)}
  .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;gap:8px;flex-wrap:wrap}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  select,input,button{background:#141414;border:1px solid #222;color:#fff;padding:8px 10px;border-radius:8px}
  button{cursor:pointer}
  #gridWrap{width:100%;overflow:hidden;border-radius:8px;background:#000;display:flex;justify-content:center}
  #grid{position:relative;touch-action:none;user-select:none}
  .cell{position:absolute;box-sizing:border-box;border:1px solid rgba(0,0,0,0.25);background-size:cover;background-position:center;overflow:hidden}
  .overlay{position:absolute;pointer-events:none}
  .player{position:absolute;display:flex;align-items:center;justify-content:center;font-size:14px}
  .hud{display:flex;gap:8px;align-items:center;color:var(--muted)}
  .controls button.big{padding:10px 12px;border-radius:8px}
  .mobile-controls{display:flex;gap:8px;justify-content:center;margin-top:10px}
  .mobile-controls button{font-size:20px;padding:12px;border-radius:10px;background:#202020;border:none;color:#fff}
  @media (max-width:420px){
    h1{font-size:16px}
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>ğŸ® Tetris Flags â€” Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ</h1>

  <div id="container">
    <div class="topbar">
      <div style="display:flex;gap:8px;align-items:center">
        <label for="modeSelect">Ù…ÙˆØ¯:</label>
        <select id="modeSelect">
          <option value="simple">ØªØªØ±ÛŒØ³ Ú©Ù„Ø§Ø³ÛŒÚ© (Ù¾Ø±Ú†Ù…â€ŒÙ‡Ø§)</option>
          <option value="escape">ÙØ±Ø§Ø± Ø¢Ø¯Ù…Ú©</option>
        </select>
        <span class="hud" id="status">ÙˆØ¶Ø¹ÛŒØª: Ø¢Ù…Ø§Ø¯Ù‡</span>
      </div>

      <div class="controls">
        <button id="startBtn" class="big">Ø´Ø±ÙˆØ¹</button>
        <button id="pauseBtn" class="big">ØªÙˆÙ‚Ù/Ø§Ø¯Ø§Ù…Ù‡</button>
        <button id="resetBtn" class="big">Ø±ÛŒØ³Øª</button>
        <button id="soundBtn">ğŸ”Š</button>
      </div>
    </div>

    <div id="gridWrap">
      <div id="grid"></div>
    </div>

    <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px;">
      <div style="display:flex;gap:8px;align-items:center">
        <button id="leftBtn">â¬…ï¸</button>
        <button id="rotateBtn">ğŸ”„</button>
        <button id="rightBtn">â¡ï¸</button>
        <button id="downBtn">â¬‡ï¸</button>
        <button id="hardDropBtn">â¤“</button>
      </div>
      <div class="hud">Ø§Ù…ØªÛŒØ§Ø²:<span id="score">0</span> &nbsp; Ø³Ø·Ø­:<span id="level">1</span></div>
    </div>

    <div class="mobile-controls" aria-hidden="false">
      <button id="mLeft">â—€</button>
      <button id="mUp">â–²</button>
      <button id="mDown">â–¼</button>
      <button id="mRight">â–¶</button>
      <button id="mRotate">âŸ³</button>
    </div>
  </div>
</div>

<script>
/* =============================
   ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ÙˆÙ„ÛŒÙ‡
   =============================*/
const GSAP = window.gsap;
const HOWLER_SRC = ["https://archive.org/download/TetrisThemeMusic/Tetris.mp3"];
const music = new Howl({ src: HOWLER_SRC, loop: true, volume: 0.45 });
let soundOn = true;

// WebAudio for sfx (short beeps)
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const aCtx = AudioCtx ? new AudioCtx() : null;
function playBeep(freq=440, time=0.05, type='sine', gain=0.05){
  if(!aCtx) return;
  const o = aCtx.createOscillator();
  const g = aCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = gain;
  o.connect(g); g.connect(aCtx.destination);
  o.start();
  o.stop(aCtx.currentTime + time);
}

/* UI elements */
const modeSelect = document.getElementById('modeSelect');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const soundBtn = document.getElementById('soundBtn');
const statusEl = document.getElementById('status');
const gridEl = document.getElementById('grid');
const scoreEl = document.getElementById('score');
const levelEl = document.getElementById('level');

const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const rotateBtn = document.getElementById('rotateBtn');
const downBtn = document.getElementById('downBtn');
const hardDropBtn = document.getElementById('hardDropBtn');

const mLeft = document.getElementById('mLeft');
const mRight = document.getElementById('mRight');
const mUp = document.getElementById('mUp');
const mDown = document.getElementById('mDown');
const mRotate = document.getElementById('mRotate');

/* Grid config */
const COLS = 10;
const ROWS = 20;
let cellSize = 0;
let gridWidth = 420;

/* Flags list (extensive) */
const FLAGS = [
 "af","al","dz","ad","ao","ar","am","au","at","az","bd","be","bz","ba","bw","br","bg","bf","bi","kh",
 "cm","ca","cv","cl","cn","co","cr","hr","cu","cy","cz","cd","dk","dj","do","ec","eg","sv","ee","et",
 "fi","fr","ga","ge","de","gh","gr","gt","ht","hn","hk","hu","is","in","id","ir","iq","ie","il","it",
 "jp","jo","kz","ke","ki","kw","la","lv","lb","ls","lr","ly","lt","lu","mk","mg","mw","my","mv","ml",
 "mt","mr","mu","mx","md","mn","me","ma","mz","mm","np","nl","nz","ni","ng","kp","no","om","pk","pa",
 "pg","py","pe","ph","pl","pt","qa","ro","ru","rw","sa","sn","rs","sc","sl","sg","sk","si","sb","za",
 "kr","es","lk","sd","se","ch","sy","tw","tj","tz","th","tl","tg","to","tt","tn","tr","tm","ug","ua",
 "ae","uk","us","uy","uz","ve","vn","ye","zm","zw"
];
const FLAG_CACHE = {};
function getFlag(code){
  if(FLAG_CACHE[code]) return FLAG_CACHE[code];
  const img = new Image();
  img.src = `https://flagcdn.com/w80/${code}.png`;
  img.onerror = ()=>{ FLAG_CACHE[code+'_err']=true; };
  FLAG_CACHE[code]=img;
  return img;
}
function randFlag(){ return FLAGS[Math.floor(Math.random()*FLAGS.length)]; }

/* Tetris pieces (4x4 matrices for rotation convenience) */
/* 1 = block, 0 = empty */
const PIECES = {
  I: [
    [[0,0,0,0],
     [1,1,1,1],
     [0,0,0,0],
     [0,0,0,0]]
  ],
  O: [
    [[0,0,0,0],
     [0,1,1,0],
     [0,1,1,0],
     [0,0,0,0]]
  ],
  T: [
    [[0,0,0,0],
     [0,1,0,0],
     [1,1,1,0],
     [0,0,0,0]]
  ],
  S: [
    [[0,0,0,0],
     [0,1,1,0],
     [1,1,0,0],
     [0,0,0,0]]
  ],
  Z: [
    [[0,0,0,0],
     [1,1,0,0],
     [0,1,1,0],
     [0,0,0,0]]
  ],
  J: [
    [[0,0,0,0],
     [1,0,0,0],
     [1,1,1,0],
     [0,0,0,0]]
  ],
  L: [
    [[0,0,0,0],
     [0,0,1,0],
     [1,1,1,0],
     [0,0,0,0]]
  ]
};
// prepare rotations (0..3) for each piece
function rotateMat(mat){
  const N = mat.length;
  const res = Array.from({length:N}, ()=>Array(N).fill(0));
  for(let r=0;r<N;r++) for(let c=0;c<N;c++) res[c][N-1-r] = mat[r][c];
  return res;
}
const PIECE_ROTATIONS = {};
for(const p in PIECES){
  PIECE_ROTATIONS[p] = [];
  let base = PIECES[p][0];
  let cur = base;
  for(let i=0;i<4;i++){
    PIECE_ROTATIONS[p].push(cur);
    cur = rotateMat(cur);
  }
}

/* Grid model: grid[r][c] = null or {flag, domEl} */
let grid = [];
function createEmptyGrid(){
  grid = Array.from({length: ROWS}, ()=> Array(COLS).fill(null));
}

/* DOM helpers */
function resizeGrid(){
  const wrap = document.getElementById('gridWrap');
  const maxWidth = Math.min(520, wrap.clientWidth - 8);
  gridWidth = maxWidth;
  cellSize = Math.floor(gridWidth / COLS);
  gridEl.style.width = (cellSize*COLS) + 'px';
  gridEl.style.height = (cellSize*ROWS) + 'px';
  gridEl.style.position = 'relative';
  renderAll();
}
window.addEventListener('resize', resizeGrid);

/* render a fixed cell at r,c from grid */
function renderCell(r,c){
  const val = grid[r][c];
  const id = `cell-${r}-${c}`;
  let el = document.getElementById(id);
  if(val){
    if(!el){
      el = document.createElement('div');
      el.id = id; el.className = 'cell';
      el.style.position = 'absolute';
      el.style.width = cellSize + 'px';
      el.style.height = cellSize + 'px';
      gridEl.appendChild(el);
    }
    el.style.left = (c*cellSize) + 'px';
    el.style.top = (r*cellSize) + 'px';
    el.style.borderRadius = (cellSize*0.06) + 'px';
    const code = val.flag;
    if(FLAG_CACHE[code+'_err']){
      el.style.background = '#444';
      el.textContent = code.toUpperCase();
      el.style.color = '#fff';
      el.style.fontSize = Math.max(10, Math.floor(cellSize*0.28)) + 'px';
      el.style.display = 'flex';
      el.style.alignItems = 'center';
      el.style.justifyContent = 'center';
    } else {
      el.style.backgroundImage = `url(${getFlag(code).src})`;
      el.textContent = '';
      el.style.backgroundSize = 'cover';
      el.style.display = '';
    }
    el.style.visibility = 'visible';
  } else {
    if(el) el.remove();
  }
}

/* overlays for active piece */
function removeActiveOverlay(){
  const olds = gridEl.querySelectorAll('[id^="active-"]');
  olds.forEach(e=>e.remove());
}
function drawActivePiece(piece){
  removeActiveOverlay();
  if(!piece) return;
  const shape = piece.shape;
  for(let r=0;r<shape.length;r++){
    for(let c=0;c<shape[r].length;c++){
      if(shape[r][c]){
        const ar = piece.r + r;
        const ac = piece.c + c;
        const el = document.createElement('div');
        el.id = `active-${r}-${c}`;
        el.className = 'cell overlay';
        el.style.width = cellSize + 'px';
        el.style.height = cellSize + 'px';
        el.style.left = (ac*cellSize) + 'px';
        el.style.top = (ar*cellSize) + 'px';
        el.style.borderRadius = (cellSize*0.06) + 'px';
        const code = piece.flag;
        if(FLAG_CACHE[code+'_err']){
          el.style.background = '#666';
          el.textContent = code.toUpperCase();
          el.style.display = 'flex';
          el.style.alignItems = 'center';
          el.style.justifyContent = 'center';
        } else {
          el.style.backgroundImage = `url(${getFlag(code).src})`;
          el.style.backgroundSize = 'cover';
        }
        gridEl.appendChild(el);
      }
    }
  }
}

/* Utilities: collision check */
function canPlace(shape, r, c){
  for(let y=0;y<shape.length;y++){
    for(let x=0;x<shape[y].length;x++){
      if(shape[y][x]){
        const nr = r + y;
        const nc = c + x;
        if(nc < 0 || nc >= COLS) return false;
        if(nr >= ROWS) return false;
        if(nr >= 0 && grid[nr][nc]) return false;
      }
    }
  }
  return true;
}

/* lock piece into grid with animation */
function lockPiece(piece){
  playBeep(220,0.06,'square',0.06);
  const shape = piece.shape;
  const toAdd = [];
  for(let y=0;y<shape.length;y++){
    for(let x=0;x<shape[y].length;x++){
      if(shape[y][x]){
        const nr = piece.r + y;
        const nc = piece.c + x;
        if(nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS){
          grid[nr][nc] = { flag: piece.flag };
          toAdd.push({r:nr,c:nc,flag:piece.flag});
        }
      }
    }
  }
  // animate pop-in
  toAdd.forEach(cell=>{
    renderCell(cell.r,cell.c);
    const el = document.getElementById(`cell-${cell.r}-${cell.c}`);
    if(el) {
      GSAP.set(el, {scale:0.2, opacity:0});
      GSAP.to(el, {scale:1, opacity:1, duration:0.18, ease:"back.out(1.4)"});
    }
  });
}

/* clear full rows with animation */
function clearFullRows(){
  const fullRows = [];
  for(let r=0;r<ROWS;r++){
    if(grid[r].every(cell => cell !== null)) fullRows.push(r);
  }
  if(fullRows.length === 0) return 0;
  // animate rows
  fullRows.forEach((r, idx) => {
    for(let c=0;c<COLS;c++){
      const id = `cell-${r}-${c}`;
      const el = document.getElementById(id);
      if(el){
        GSAP.to(el, {y: -20, opacity:0, scale:0.6, duration:0.3, delay: idx*0.05});
      }
    }
  });
  // after animation, remove rows and collapse
  setTimeout(()=>{
    // remove DOM for those rows
    fullRows.sort((a,b)=>a-b);
    for(let ri = fullRows.length -1; ri>=0; ri--){
      const r = fullRows[ri];
      grid.splice(r,1);
      grid.unshift(Array(COLS).fill(null));
    }
    // re-render whole grid
    removeAllCells();
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) renderCell(r,c);
  }, 380 + fullRows.length*30);
  // sfx
  playBeep(880,0.08,'sine',0.04);
  return fullRows.length;
}

function removeAllCells(){
  while(gridEl.firstChild) gridEl.removeChild(gridEl.firstChild);
}

/* Piece generation (random bag) */
let bag = [];
function refillBag(){
  bag = Object.keys(PIECE_ROTATIONS).slice();
  // shuffle
  for(let i=bag.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [bag[i],bag[j]] = [bag[j],bag[i]];
  }
}
function nextPiece(){ 
  if(bag.length === 0) refillBag();
  const type = bag.shift();
  const rot = 0;
  const shape = PIECE_ROTATIONS[type][rot];
  const flag = randFlag();
  // initial position: center horizontally, r = -topOffset
  const topOffset = getTopOffset(shape);
  const startR = -topOffset;
  const startC = Math.floor((COLS - shape[0].length)/2);
  return { type, rotation: rot, shape: shape, r: startR, c: startC, flag };
}
function rotatePiece(piece){
  const rots = PIECE_ROTATIONS[piece.type];
  const nextRot = (piece.rotation + 1) % rots.length;
  const nextShape = rots[nextRot];
  return { ...piece, rotation: nextRot, shape: nextShape };
}
function getTopOffset(shape){
  for(let r=0;r<shape.length;r++){
    if(shape[r].some(v=>v)) return r;
  }
  return 0;
}

/* Game state */
let running = false;
let paused = false;
let mode = 'simple';
let current = null;
let ghost = null;
let dropInterval = 700; // ms per step; decreases with level
let dropAccumulator = 0;
let lastTime = 0;
let score = 0;
let level = 1;

/* Start / Pause / Reset */
function startGame(){
  if(!running) {
    mode = modeSelect.value;
    running = true; paused = false;
    createEmptyGrid();
    removeAllCells();
    refillBag();
    current = nextPiece();
    score = 0; level = 1;
    scoreEl.textContent = score; levelEl.textContent = level;
    dropInterval = 700;
    lastTime = performance.now();
    statusEl.textContent = `Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø²ÛŒ: ${mode}`;
    if(soundOn) try{ music.play(); }catch(e){}
    requestAnimationFrame(loop);
  } else {
    // restart
    resetGame();
    startGame();
  }
}
function pauseGame(){
  if(!running) return;
  paused = !paused;
  if(!paused){
    lastTime = performance.now();
    requestAnimationFrame(loop);
    statusEl.textContent = 'Ø§Ø¯Ø§Ù…Ù‡';
  } else {
    statusEl.textContent = 'Ù…ØªÙˆÙ‚Ù';
  }
}
function resetGame(){
  running = false; paused = false;
  createEmptyGrid();
  removeAllCells();
  current = null;
  refillBag();
  score = 0; level = 1;
  scoreEl.textContent = score; levelEl.textContent = level;
  try{ music.stop(); }catch(e){}
  statusEl.textContent = 'Ø¢Ù…Ø§Ø¯Ù‡';
}

/* Drop & Lock logic */
function hardDrop(){
  if(!current) return;
  while(true){
    if(canPlace(current.shape, current.r+1, current.c)) current.r++;
    else break;
  }
  lockAndNext();
  playBeep(520,0.02,'square',0.06);
}
function softDrop(){
  if(!current) return;
  if(canPlace(current.shape, current.r+1, current.c)) {
    current.r++;
    score += 1;
    scoreEl.textContent = score;
    playBeep(400,0.02,'sine',0.02);
  } else {
    lockAndNext();
  }
}
function moveLeft(){
  if(!current) return;
  if(canPlace(current.shape, current.r, current.c-1)){
    current.c--;
    playBeep(260,0.02,'sine',0.02);
  }
}
function moveRight(){
  if(!current) return;
  if(canPlace(current.shape, current.r, current.c+1)){
    current.c++;
    playBeep(260,0.02,'sine',0.02);
  }
}
function rotateCW(){
  if(!current) return;
  const rots = PIECE_ROTATIONS[current.type];
  const nextRot = (current.rotation + 1) % rots.length;
  const nextShape = rots[nextRot];
  // try kicks: basic wall kick attempts
  const kicks = [[0,0],[0,-1],[0,1],[-1,0],[1,0]];
  for(const k of kicks){
    const nr = current.r + k[0];
    const nc = current.c + k[1];
    if(canPlace(nextShape, nr, nc)){
      current.rotation = nextRot;
      current.shape = nextShape;
      current.r = nr; current.c = nc;
      playBeep(600,0.03,'triangle',0.03);
      return;
    }
  }
}

/* lock current piece and spawn next */
function lockAndNext(){
  lockPiece(current);
  const cleared = clearFullRows();
  if(cleared > 0){
    score += 100 * cleared;
    level = Math.min(20, Math.floor(score/500) + 1);
    dropInterval = Math.max(120, 700 - (level-1) * 30);
    levelEl.textContent = level;
    playBeep(900,0.12,'sine',0.05);
  }
  current = nextPiece();
  // check immediate collision -> game over
  if(!canPlace(current.shape, current.r, current.c)){
    gameOver();
  }
}

/* game over */
function gameOver(){
  running = false;
  paused = false;
  try{ music.stop(); }catch(e){}
  statusEl.textContent = 'Ø¨Ø§Ø®Øª';
  playBeep(120,0.4,'sine',0.08);
  setTimeout(()=> alert('Ø¨Ø§Ø®ØªÛŒ! Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†.'), 50);
}

/* render all static cells and active piece */
function renderAll(){
  // render static grid
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) renderCell(r,c);
  // render active piece overlay
  drawActivePiece(current);
}

/* Game loop (requestAnimationFrame) */
function loop(now){
  if(!running || paused) return;
  const dt = now - lastTime;
  lastTime = now;
  dropAccumulator += dt;
  // step
  if(dropAccumulator >= dropInterval){
    dropAccumulator -= dropInterval;
    if(mode === 'simple'){
      if(canPlace(current.shape, current.r+1, current.c)){
        current.r++;
      } else {
        lockAndNext();
      }
    } else if(mode === 'escape'){
      // in escape: spawn and patterns settle into grid (simpler approach preserved from earlier)
      // We'll reuse a simple escape logic: spawn horizontal patterns guaranteeing a hole
      // For brevity we use a local spawn scheduler implemented below (escape-specific)
      escapeTick();
    }
  }
  renderAll();
  requestAnimationFrame(loop);
}

/* =========================
   Escape mode: patterns dropping (grid-based)
   =========================*/
let escapePatterns = [];
let escapeSpawnAcc = 0;
let escapeSpawnInterval = 1000;
function spawnEscapePattern(){
  // patterns generated like earlier, but we ensure at least one column hole
  const t = Math.random();
  const blocks = [];
  if(t < 0.5){
    // row with 1-2 holes
    let holes = Math.random() < 0.7 ? 1 : 2;
    const holeIdx = [];
    while(holeIdx.length < holes){
      const idx = Math.floor(Math.random()*COLS);
      if(!holeIdx.includes(idx)) holeIdx.push(idx);
    }
    for(let c=0;c<COLS;c++){
      if(!holeIdx.includes(c)) blocks.push({r: -1, c, flag: randFlag()});
    }
  } else if(t < 0.8){
    // some columns
    const cnt = 3 + Math.floor(Math.random()*3);
    const cols = [];
    while(cols.length < cnt){
      const c = Math.floor(Math.random()*COLS);
      if(!cols.includes(c)) cols.push(c);
    }
    cols.forEach(c=>{
      const h = 1 + Math.floor(Math.random()*2);
      for(let k=0;k<h;k++) blocks.push({r: -1 - k, c, flag: randFlag()});
    });
  } else {
    // random single blocks
    const cnt = 2 + Math.floor(Math.random()*4);
    for(let i=0;i<cnt;i++){
      const c = Math.floor(Math.random()*COLS);
      blocks.push({r: -1 - Math.floor(Math.random()*3), c, flag: randFlag()});
    }
  }
  // ensure at least one hole at settle: compute max fall
  let maxFall = ROWS;
  for(const b of blocks){
    let fall = 0;
    for(let r = b.r + 1; r < ROWS; r++)
